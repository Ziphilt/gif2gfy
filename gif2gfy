#!/bin/sh

# Make script halt if encountering an error, as opposed to the standard shell
# behavior of ingoring them
set -e

INPUT="${1}"

# Use a POSIX-friendly way to detect whether a command is installed
is_available() {
  command -v "${1}" > /dev/null 2>&1
}

if is_available "ffmpeg"; then
  BACKEND="ffmpeg"
else
  BACKEND="ffmpeg-2.4.2-64bit-static/ffmpeg"
  #echo "FFmpeg needs to be installed to continue. Aborting."
  #exit 1
fi

if [ -z "${INPUT}" ]; then
  echo "No file specified. Aborting."
  exit 1
fi

if [ ! -f "${INPUT}" ]; then
  echo "${INPUT} isn't a file. Aborting."
  exit 1
fi

MIMETYPE="$(file --mime-type ${INPUT})"
MIMETYPE="${MIMETYPE#* }"

# Temporary location for FFmpeg output that'll be deleted once the script ends
GFY="$(mktemp --dry-run --suffix=.webm)" || echo 1
trap 'rm -rf "${GFY}"' EXIT

# If file is .webm, then simply extract the encoded video losslessly
if [ "${MIMETYPE}" = "video/webm" ]; then
  "${BACKEND}" -i "${INPUT}" -vcodec copy -an "${GFY}"

elif [ "${MIMETYPE}" = "image/gif" ]; then
  Q="3.75M"
  PARAMETERS="-minrate ${Q} -maxrate ${Q} -b:v ${Q}"
  ${BACKEND} -i "${INPUT}" ${PARAMETERS} "${GFY}"
else
  echo "Not a supported filetype. Aborting."
  exit 1
fi

TITLE="${GFY}"
WIDTH=""
HEIGHT=""
DATA="$(base64 -w 0 "${GFY}")"

cat << HTML > output.webm.html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>${TITLE} (${WIDTH}x${HEIGHT}px)</title>
    <style type="text/css">
      body {
        margin: 0px;
        text-align: center;
        background-color: black;
      }
     </style>
  <head>
  <body>
    <video width="${WIDTH}" height="${HEIGHT}" autoplay="autoplay" loop="">
      <source type="${MIMETYPE}" src="${MIMETYPE};base64,${DATA}">
    </video>
  </body>
</html>"
HTML
